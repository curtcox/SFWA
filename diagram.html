<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Diagram Editor (SFWA)</title>
  <style>
    :root {
      --bg: #0b0d10;
      --panel: #12161c;
      --panel2: #0f1318;
      --text: #e8edf3;
      --muted: #aeb7c2;
      --line: #263041;
      --good: #78dba9;
      --bad: #ff6b6b;
      --warn: #ffd166;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text); font-family: var(--sans); }
    .app { height: 100%; display: flex; flex-direction: column; }
    .topbar {
      display: flex; gap: 10px; align-items: center;
      padding: 10px 12px; border-bottom: 1px solid var(--line);
      background: linear-gradient(180deg, #0e1218, #0b0d10);
    }
    .title { font-weight: 700; letter-spacing: 0.2px; }
    .pill {
      font-size: 12px; color: var(--muted);
      padding: 3px 8px; border: 1px solid var(--line);
      border-radius: 999px; background: rgba(255,255,255,0.03);
    }
    .btn {
      background: rgba(255,255,255,0.06);
      border: 1px solid var(--line);
      color: var(--text);
      padding: 7px 10px; border-radius: 10px;
      cursor: pointer; font-weight: 600;
    }
    .btn:hover { background: rgba(255,255,255,0.10); }
    .btn:active { transform: translateY(1px); }
    .btn.secondary { font-weight: 600; color: var(--muted); }
    .spacer { flex: 1; }
    .status { font-size: 12px; color: var(--muted); display: flex; gap: 10px; align-items: center; }
    .status .ok { color: var(--good); }
    .status .err { color: var(--bad); }
    .status .warn { color: var(--warn); }
    .main { flex: 1; display: flex; min-height: 0; }
    .left, .right { min-width: 0; }
    .left {
      width: 42%;
      display: flex; flex-direction: column;
      border-right: 1px solid var(--line);
      background: var(--panel);
    }
    .right {
      flex: 1;
      background: radial-gradient(1000px 600px at 70% 20%, rgba(91, 156, 255, 0.12), transparent 60%),
                  radial-gradient(900px 500px at 40% 80%, rgba(120, 219, 169, 0.10), transparent 60%),
                  var(--panel2);
      position: relative;
    }
    .editorBar {
      padding: 10px 12px; display: flex; gap: 8px; align-items: center;
      border-bottom: 1px solid var(--line);
    }
    .editorBar .hint { font-size: 12px; color: var(--muted); }
    textarea {
      flex: 1; width: 100%;
      border: 0; outline: none; resize: none;
      padding: 12px;
      background: #0f1318; color: var(--text);
      font-family: var(--mono); font-size: 13px; line-height: 1.35;
      border-top: 1px solid rgba(255,255,255,0.04);
    }
    .help {
      border-top: 1px solid var(--line);
      padding: 10px 12px;
      font-size: 12px; color: var(--muted);
      background: rgba(255,255,255,0.02);
      overflow: auto;
      max-height: 42%;
    }
    .help h3 { margin: 8px 0 6px; font-size: 12px; color: var(--text); }
    .help code, .help pre {
      font-family: var(--mono);
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(255,255,255,0.06);
      padding: 1px 6px; border-radius: 8px;
      color: var(--text);
    }
    .help .grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; }
    .help .box {
      border: 1px solid rgba(255,255,255,0.07);
      border-radius: 12px;
      padding: 10px;
      background: rgba(0,0,0,0.18);
    }
    .help ul { margin: 6px 0 0; padding-left: 16px; }
    .help li { margin: 3px 0; }
    .errorBox {
      display: none;
      padding: 8px 12px;
      border-top: 1px solid rgba(255,255,255,0.06);
      background: rgba(255, 107, 107, 0.12);
      color: #ffd7d7;
      font-family: var(--mono);
      font-size: 12px;
      white-space: pre-wrap;
    }
    .errorBox.show { display: block; }
    .svgWrap { position: absolute; inset: 0; }
    svg { width: 100%; height: 100%; display: block; }
    .legend {
      position: absolute; left: 12px; bottom: 12px;
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 14px;
      padding: 10px 12px;
      font-size: 12px;
      color: var(--muted);
      max-width: 420px;
      backdrop-filter: blur(6px);
    }
    .legend b { color: var(--text); }
    .legend .row { margin-top: 6px; display: flex; gap: 10px; flex-wrap: wrap; }
    .kbd {
      font-family: var(--mono);
      padding: 1px 6px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.04);
      color: var(--text);
    }
  </style>
</head>
<body>
<div class="app">
  <div class="topbar">
    <div class="title">Diagram Editor</div>
    <div class="pill">SFWA • all state in URL hash</div>
    <div class="spacer"></div>
    <button class="btn secondary" id="btnCommit" title="Push a history entry (Back/Forward friendly).">Commit snapshot</button>
    <button class="btn" id="btnCopy">Copy URL</button>
    <button class="btn secondary" id="btnReset">Reset</button>
    <div class="status">
      <span id="parseStatus" class="ok">OK</span>
      <span id="hashStatus" class="pill">hash: 0 chars</span>
    </div>
  </div>

  <div class="main">
    <div class="left">
      <div class="editorBar">
        <div class="hint">
          Edit text → diagram updates → URL updates. Drag nodes → positions saved in URL.
        </div>
      </div>

      <textarea id="src" spellcheck="false"></textarea>
      <div id="errorBox" class="errorBox"></div>

      <div class="help" id="help">
        <h3>Diagram definition language</h3>
        <div class="box">
          <div><code>#</code> starts a comment. Inline comments are supported.</div>
          <div style="margin-top:8px;">
            <b>Node line</b>:
            <code>n  [shape] [color] [url] [text...]</code>
          </div>
          <div style="margin-top:6px;">
            <b>Edge line</b>:
            <code>a -> b (-> c ...)  [lineStyle] [color] [url] [text...]</code>
          </div>
          <div style="margin-top:8px;">
            Attribute order is fixed:
            <code>style, color, URL fragment, text</code>
            — but any can be omitted.
          </div>
          <div style="margin-top:8px;">
            URL token: <code>/example.com</code> becomes <code>https://example.com</code>.
            You can also use <code>https://...</code> directly.
          </div>
          <div style="margin-top:10px;">
            Examples:
            <pre style="margin:0; padding:8px 10px; border-radius:12px; border:1px solid rgba(255,255,255,0.08); background: rgba(255,255,255,0.03); overflow:auto;"># nodes
n square red /google.com Extra text that will be associated with node n

# edges
n1 -> n2          # define 2 connected nodes
n1 -> n2 -> n3    # 3 connected nodes
a -> b dotted blue /slashdot.org Extra text that will be associated with edge from a to b</pre>
          </div>
        </div>

        <h3>Reserved words</h3>
        <div class="grid">
          <div class="box">
            <div><b>Node shapes</b> (style)</div>
            <ul id="shapeList"></ul>
          </div>
          <div class="box">
            <div><b>Colors</b></div>
            <ul id="colorList"></ul>
          </div>
          <div class="box">
            <div><b>Edge line styles</b> (style)</div>
            <ul id="lineStyleList"></ul>
          </div>
        </div>

        <h3>Interactions</h3>
        <div class="box">
          <div class="row" style="margin-top:0;">
            <span class="kbd">drag</span> move nodes
            <span class="kbd">hover</span> see node/edge text
            <span class="kbd">click</span> follow node/edge link
          </div>
          <div style="margin-top:8px;">
            Tip: use <b>Commit snapshot</b> to create Back/Forward checkpoints while you edit.
          </div>
        </div>
      </div>
    </div>

    <div class="right">
      <div class="svgWrap">
        <svg id="svg" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Diagram"></svg>
      </div>

      <div class="legend">
        <div><b>Shareable state:</b> source + node positions are encoded in the URL hash.</div>
        <div class="row">
          <span>Try: edit the text, then copy the URL.</span>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  // -----------------------------
  // Reserved vocab
  // -----------------------------
  const NODE_SHAPES = ["circle", "square", "diamond", "triangle", "hex"];
  const EDGE_STYLES = ["solid", "dashed", "dotted", "bold"];

  const COLORS = {
    gray:   "#9aa4b2",
    black:  "#1f2937",
    white:  "#f8fafc",
    red:    "#ef4444",
    orange: "#f97316",
    yellow: "#eab308",
    green:  "#22c55e",
    teal:   "#14b8a6",
    blue:   "#3b82f6",
    purple: "#a855f7",
    pink:   "#ec4899",
    brown:  "#92400e",
  };

  // -----------------------------
  // UI wiring
  // -----------------------------
  const $src = document.getElementById("src");
  const $svg = document.getElementById("svg");
  const $parseStatus = document.getElementById("parseStatus");
  const $hashStatus = document.getElementById("hashStatus");
  const $errorBox = document.getElementById("errorBox");

  const $shapeList = document.getElementById("shapeList");
  const $colorList = document.getElementById("colorList");
  const $lineStyleList = document.getElementById("lineStyleList");

  function fillList(ul, items) {
    ul.innerHTML = "";
    for (const it of items) {
      const li = document.createElement("li");
      li.textContent = it;
      ul.appendChild(li);
    }
  }
  fillList($shapeList, NODE_SHAPES);
  fillList($lineStyleList, EDGE_STYLES);
  fillList($colorList, Object.keys(COLORS));

  document.getElementById("btnCopy").addEventListener("click", async () => {
    try {
      await navigator.clipboard.writeText(location.href);
      flashStatus("Copied URL", "ok");
    } catch {
      // Fallback
      const tmp = document.createElement("textarea");
      tmp.value = location.href;
      document.body.appendChild(tmp);
      tmp.select();
      document.execCommand("copy");
      document.body.removeChild(tmp);
      flashStatus("Copied URL (fallback)", "ok");
    }
  });

  document.getElementById("btnReset").addEventListener("click", () => {
    applyState(makeDefaultState(), { replace: true });
    renderAll();
    syncHash({ replace: true });
  });

  document.getElementById("btnCommit").addEventListener("click", () => {
    syncHash({ replace: false }); // pushState for milestone
    flashStatus("Committed snapshot", "ok");
  });

  function flashStatus(text, kind) {
    const prev = $parseStatus.textContent;
    const prevClass = $parseStatus.className;
    $parseStatus.textContent = text;
    $parseStatus.className = (kind === "err") ? "err" : (kind === "warn") ? "warn" : "ok";
    setTimeout(() => {
      $parseStatus.textContent = prev;
      $parseStatus.className = prevClass;
    }, 900);
  }

  // -----------------------------
  // Hash state encoding (all state in URL fragment)
  // -----------------------------
  // State = { src: string, pos: { [nodeId]: [x,y] } }
  const HASH_PREFIX = "h1=";

  function bytesToBase64Url(bytes) {
    let bin = "";
    for (let i = 0; i < bytes.length; i++) bin += String.fromCharCode(bytes[i]);
    const b64 = btoa(bin);
    return b64.replaceAll("+", "-").replaceAll("/", "_").replaceAll("=", "");
  }

  function base64UrlToBytes(b64url) {
    const padLen = (4 - (b64url.length % 4)) % 4;
    const b64 = (b64url + "====".slice(0, padLen)).replaceAll("-", "+").replaceAll("_", "/");
    const bin = atob(b64);
    const bytes = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);
    return bytes;
  }

  function encodeState(state) {
    const json = JSON.stringify(state);
    const bytes = new TextEncoder().encode(json);
    return HASH_PREFIX + bytesToBase64Url(bytes);
    // Note: for very large diagrams you may want compression,
    // but this keeps the file dependency-free.
  }

  function decodeState(hash) {
    // Expect: #h1=...
    const raw = (hash.startsWith("#") ? hash.slice(1) : hash).trim();
    if (!raw) return null;
    if (!raw.startsWith(HASH_PREFIX)) return null;
    const payload = raw.slice(HASH_PREFIX.length);
    const bytes = base64UrlToBytes(payload);
    const json = new TextDecoder().decode(bytes);
    return JSON.parse(json);
  }

  let ignoreHashChange = false;

  function syncHash({ replace } = { replace: true }) {
    const encoded = encodeState(state);
    const newHash = "#" + encoded;
    ignoreHashChange = true;
    if (replace) history.replaceState(null, "", newHash);
    else history.pushState(null, "", newHash);
    ignoreHashChange = false;
    updateHashStatus();
  }

  function updateHashStatus() {
    $hashStatus.textContent = `hash: ${location.hash.length} chars`;
  }

  window.addEventListener("hashchange", () => {
    if (ignoreHashChange) return;
    const incoming = decodeState(location.hash);
    if (!incoming) return;
    applyState(incoming, { replace: true, fromHash: true });
    renderAll();
  });

  // -----------------------------
  // Parsing DSL
  // -----------------------------
  function stripInlineComment(line) {
    const t = line.trim();
    if (!t) return "";
    if (t.startsWith("#")) return "";
    // Inline: treat first " #" as comment start (space before #)
    const idx = line.search(/\s#/);
    if (idx >= 0) return line.slice(0, idx).trimEnd();
    return line.trimEnd();
  }

  function splitWS(s) {
    return s.trim().length ? s.trim().split(/\s+/) : [];
  }

  function looksLikeUrlToken(tok) {
    if (!tok) return false;
    if (tok.startsWith("/")) return true;
    if (tok.startsWith("http://") || tok.startsWith("https://")) return true;
    if (tok.startsWith("mailto:")) return true;
    if (tok.startsWith("www.")) return true;
    return false;
  }

  function normalizeUrl(tok) {
    if (!tok) return "";
    if (tok.startsWith("/")) return "https://" + tok.slice(1);
    if (tok.startsWith("www.")) return "https://" + tok;
    return tok;
  }

  function isValidId(id) {
    // Keep it simple; allow common graph ids
    return /^[A-Za-z0-9_:\-]+$/.test(id);
  }

  function parseAttrs(tokens, kind) {
    // Order: style, color, url, text
    // But each optional, so we detect by reserved sets.
    let i = 0;

    let style = "";
    let color = "";
    let url = "";
    let text = "";

    if (tokens[i]) {
      if (kind === "node" && NODE_SHAPES.includes(tokens[i])) {
        style = tokens[i++]; // shape
      } else if (kind === "edge" && EDGE_STYLES.includes(tokens[i])) {
        style = tokens[i++]; // line style
      }
    }

    if (tokens[i] && Object.prototype.hasOwnProperty.call(COLORS, tokens[i])) {
      color = tokens[i++];
    }

    if (tokens[i] && looksLikeUrlToken(tokens[i])) {
      url = normalizeUrl(tokens[i++]);
    }

    if (i < tokens.length) {
      text = tokens.slice(i).join(" ");
    }

    return { style, color, url, text };
  }

  function parseSource(src) {
    const nodes = new Map(); // id -> {id, shape, color, url, text}
    const edges = [];        // {from,to, style,color,url,text, key}

    const errors = [];
    const lines = src.split(/\r?\n/);

    function ensureNode(id) {
      if (!nodes.has(id)) {
        nodes.set(id, {
          id,
          shape: "circle",
          color: "gray",
          url: "",
          text: "",
        });
      }
      return nodes.get(id);
    }

    for (let lineNo = 0; lineNo < lines.length; lineNo++) {
      const raw = lines[lineNo];
      const line = stripInlineComment(raw);
      if (!line.trim()) continue;

      if (line.includes("->")) {
        // Edge line (possibly chain)
        const segs = line.split("->").map(s => s.trim()).filter(Boolean);
        if (segs.length < 2) {
          errors.push(`Line ${lineNo+1}: malformed edge line`);
          continue;
        }

        // Last segment may contain attrs after the last node id
        const lastTokens = splitWS(segs[segs.length - 1]);
        if (lastTokens.length === 0) {
          errors.push(`Line ${lineNo+1}: missing last node id`);
          continue;
        }

        const chainIds = [];
        for (let i = 0; i < segs.length - 1; i++) {
          const tok = splitWS(segs[i])[0];
          if (!tok || !isValidId(tok)) {
            errors.push(`Line ${lineNo+1}: invalid node id "${tok || segs[i]}"`);
            continue;
          }
          chainIds.push(tok);
        }

        const lastId = lastTokens[0];
        if (!isValidId(lastId)) {
          errors.push(`Line ${lineNo+1}: invalid node id "${lastId}"`);
          continue;
        }
        chainIds.push(lastId);

        const attrs = parseAttrs(lastTokens.slice(1), "edge");
        // Apply to every edge in chain
        for (let i = 0; i < chainIds.length - 1; i++) {
          const from = chainIds[i];
          const to = chainIds[i + 1];
          ensureNode(from);
          ensureNode(to);

          edges.push({
            from, to,
            style: attrs.style || "solid",
            color: attrs.color || "gray",
            url: attrs.url || "",
            text: attrs.text || "",
            key: `${from}->${to}#${edges.length}` // allow duplicates
          });
        }
      } else {
        // Node line
        const tokens = splitWS(line);
        const id = tokens[0];
        if (!id || !isValidId(id)) {
          errors.push(`Line ${lineNo+1}: invalid node id "${id || line}"`);
          continue;
        }
        const attrs = parseAttrs(tokens.slice(1), "node");
        const n = ensureNode(id);
        if (attrs.style) n.shape = attrs.style;
        if (attrs.color) n.color = attrs.color;
        if (attrs.url) n.url = attrs.url;
        if (attrs.text) n.text = attrs.text;
        // If attrs.text is empty, we keep prior text (so a later "id" line won't wipe it accidentally).
      }
    }

    // Prune accidental empty duplicates? We'll just keep as parsed.

    return { nodes, edges, errors };
  }

  // -----------------------------
  // Layout + Rendering (SVG)
  // -----------------------------
  const NODE_W = 110;
  const NODE_H = 64;

  function hexToRgb(hex) {
    const h = hex.replace("#", "").trim();
    const v = parseInt(h, 16);
    if (h.length !== 6 || Number.isNaN(v)) return { r: 200, g: 200, b: 200 };
    return { r: (v >> 16) & 255, g: (v >> 8) & 255, b: v & 255 };
  }

  function rgba(hex, a) {
    const { r, g, b } = hexToRgb(hex);
    return `rgba(${r},${g},${b},${a})`;
  }

  function luminance(hex) {
    const { r, g, b } = hexToRgb(hex);
    const srgb = [r, g, b].map(v => {
      const x = v / 255;
      return x <= 0.03928 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
    });
    return 0.2126 * srgb[0] + 0.7152 * srgb[1] + 0.0722 * srgb[2];
  }

  function ensurePositions(diagram) {
    const rect = $svg.getBoundingClientRect();
    const W = Math.max(400, rect.width);
    const H = Math.max(300, rect.height);

    const ids = Array.from(diagram.nodes.keys()).sort();
    const missing = ids.filter(id => !state.pos[id] || !Array.isArray(state.pos[id]));

    if (missing.length === 0) return;

    // Place missing nodes around a circle
    const cx = W * 0.5;
    const cy = H * 0.5;
    const r = Math.min(W, H) * 0.32;

    // Count total for stable distribution
    const all = ids;
    for (let i = 0; i < all.length; i++) {
      const id = all[i];
      if (state.pos[id]) continue;
      const ang = (i / Math.max(1, all.length)) * Math.PI * 2;
      const x = cx + Math.cos(ang) * r;
      const y = cy + Math.sin(ang) * r;
      state.pos[id] = [Math.round(x), Math.round(y)];
    }
  }

  function prunePositions(diagram) {
    const live = new Set(diagram.nodes.keys());
    for (const id of Object.keys(state.pos)) {
      if (!live.has(id)) delete state.pos[id];
    }
  }

  function svgPointFromEvent(evt) {
    const pt = $svg.createSVGPoint();
    pt.x = evt.clientX;
    pt.y = evt.clientY;
    const ctm = $svg.getScreenCTM();
    if (!ctm) return { x: 0, y: 0 };
    const inv = ctm.inverse();
    const p = pt.matrixTransform(inv);
    return { x: p.x, y: p.y };
  }

  function applyEdgeStyle(style, colorName) {
    const color = COLORS[colorName] || COLORS.gray;
    const props = {
      stroke: color,
      "stroke-width": (style === "bold") ? 3.5 : 2.2,
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-dasharray": "",
    };
    if (style === "dashed") props["stroke-dasharray"] = "10 7";
    if (style === "dotted") props["stroke-dasharray"] = "2 7";
    return props;
  }

  function markerIdFor(colorName) {
    return `arrow-${colorName}`;
  }

  function buildMarkers(defsEl) {
    // Create one arrow marker per color name to match edge stroke.
    for (const name of Object.keys(COLORS)) {
      const col = COLORS[name];
      const marker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
      marker.setAttribute("id", markerIdFor(name));
      marker.setAttribute("markerWidth", "10");
      marker.setAttribute("markerHeight", "10");
      marker.setAttribute("refX", "9");
      marker.setAttribute("refY", "5");
      marker.setAttribute("orient", "auto");
      marker.setAttribute("markerUnits", "strokeWidth");

      const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
      path.setAttribute("d", "M 0 0 L 10 5 L 0 10 z");
      path.setAttribute("fill", col);

      marker.appendChild(path);
      defsEl.appendChild(marker);
    }
  }

  function nodeRadius(shape) {
    // Rough collision/edge endpoint offset
    if (shape === "circle") return Math.max(NODE_W, NODE_H) * 0.32;
    if (shape === "triangle" || shape === "diamond" || shape === "hex") return Math.max(NODE_W, NODE_H) * 0.36;
    return Math.max(NODE_W, NODE_H) * 0.34; // square-ish
  }

  function edgeEndpoints(a, b, shapeA, shapeB) {
    const ax = a[0], ay = a[1];
    const bx = b[0], by = b[1];
    const dx = bx - ax, dy = by - ay;
    const len = Math.hypot(dx, dy) || 1;
    const ux = dx / len, uy = dy / len;

    const ra = nodeRadius(shapeA);
    const rb = nodeRadius(shapeB);

    const x1 = ax + ux * ra;
    const y1 = ay + uy * ra;
    const x2 = bx - ux * rb;
    const y2 = by - uy * rb;

    return { x1, y1, x2, y2, ux, uy, len };
  }

  function truncateLabel(s, n) {
    if (!s) return "";
    return s.length > n ? s.slice(0, n - 1) + "…" : s;
  }

  function render(diagram) {
    // Setup svg coordinate system in pixels
    const rect = $svg.getBoundingClientRect();
    const W = Math.max(400, rect.width);
    const H = Math.max(300, rect.height);

    $svg.setAttribute("viewBox", `0 0 ${W} ${H}`);
    $svg.innerHTML = "";

    const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
    buildMarkers(defs);
    $svg.appendChild(defs);

    // A subtle grid background
    const bg = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    bg.setAttribute("x", "0"); bg.setAttribute("y", "0");
    bg.setAttribute("width", W); bg.setAttribute("height", H);
    bg.setAttribute("fill", "transparent");
    $svg.appendChild(bg);

    // Draw edges under nodes
    const edgeLayer = document.createElementNS("http://www.w3.org/2000/svg", "g");
    const nodeLayer = document.createElementNS("http://www.w3.org/2000/svg", "g");
    $svg.appendChild(edgeLayer);
    $svg.appendChild(nodeLayer);

    // Edge rendering
    for (const e of diagram.edges) {
      const fromPos = state.pos[e.from];
      const toPos = state.pos[e.to];
      const fromNode = diagram.nodes.get(e.from);
      const toNode = diagram.nodes.get(e.to);
      if (!fromPos || !toPos || !fromNode || !toNode) continue;

      const { x1, y1, x2, y2, ux, uy } = edgeEndpoints(fromPos, toPos, fromNode.shape, toNode.shape);

      const g = document.createElementNS("http://www.w3.org/2000/svg", "g");

      // Visible stroke
      const p = document.createElementNS("http://www.w3.org/2000/svg", "path");
      p.setAttribute("d", `M ${x1} ${y1} L ${x2} ${y2}`);

      const styleProps = applyEdgeStyle(e.style || "solid", e.color || "gray");
      for (const [k, v] of Object.entries(styleProps)) p.setAttribute(k, v);

      p.setAttribute("fill", "none");
      p.setAttribute("marker-end", `url(#${markerIdFor(e.color || "gray")})`);

      // Hover text
      const title = document.createElementNS("http://www.w3.org/2000/svg", "title");
      const tText = [
        `${e.from} -> ${e.to}`,
        e.text ? `text: ${e.text}` : "",
        e.url ? `link: ${e.url}` : ""
      ].filter(Boolean).join("\n");
      title.textContent = tText;
      p.appendChild(title);

      // Click overlay for edges (fatter invisible stroke)
      const hit = document.createElementNS("http://www.w3.org/2000/svg", "path");
      hit.setAttribute("d", `M ${x1} ${y1} L ${x2} ${y2}`);
      hit.setAttribute("fill", "none");
      hit.setAttribute("stroke", "transparent");
      hit.setAttribute("stroke-width", "14");
      hit.style.cursor = e.url ? "pointer" : "default";
      hit.addEventListener("click", (ev) => {
        ev.stopPropagation();
        if (e.url) safeOpen(e.url);
      });

      // Edge label (optional)
      if (e.text) {
        const mx = (x1 + x2) / 2;
        const my = (y1 + y2) / 2;
        // Offset label slightly perpendicular
        const px = -uy, py = ux;
        const tx = mx + px * 10;
        const ty = my + py * 10;

        const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
        label.setAttribute("x", tx);
        label.setAttribute("y", ty);
        label.setAttribute("text-anchor", "middle");
        label.setAttribute("dominant-baseline", "middle");
        label.setAttribute("font-family", "system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial");
        label.setAttribute("font-size", "12");
        label.setAttribute("fill", "rgba(232,237,243,0.85)");
        label.setAttribute("paint-order", "stroke");
        label.setAttribute("stroke", "rgba(0,0,0,0.6)");
        label.setAttribute("stroke-width", "3");
        label.style.pointerEvents = "none";
        label.textContent = truncateLabel(e.text, 28);
        g.appendChild(label);
      }

      g.appendChild(p);
      g.appendChild(hit);
      edgeLayer.appendChild(g);
    }

    // Node rendering
    for (const [id, n] of diagram.nodes.entries()) {
      const pos = state.pos[id];
      if (!pos) continue;
      const x = pos[0], y = pos[1];

      const col = COLORS[n.color] || COLORS.gray;
      const fillCol = rgba(col, 0.18);
      const strokeCol = rgba(col, 0.85);
      const labelCol = luminance(col) < 0.38 ? "rgba(248,250,252,0.95)" : "rgba(15,23,42,0.92)";

      const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
      g.setAttribute("data-node-id", id);
      g.style.cursor = "grab";

      // Hover text
      const title = document.createElementNS("http://www.w3.org/2000/svg", "title");
      const tText = [
        id,
        n.text ? `text: ${n.text}` : "",
        n.url ? `link: ${n.url}` : ""
      ].filter(Boolean).join("\n");
      title.textContent = tText;
      g.appendChild(title);

      // Shape
      const shape = (n.shape && NODE_SHAPES.includes(n.shape)) ? n.shape : "circle";
      let el;

      if (shape === "circle") {
        el = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        el.setAttribute("cx", x);
        el.setAttribute("cy", y);
        el.setAttribute("r", Math.min(NODE_W, NODE_H) * 0.42);
      } else if (shape === "square") {
        el = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        el.setAttribute("x", x - NODE_W / 2);
        el.setAttribute("y", y - NODE_H / 2);
        el.setAttribute("width", NODE_W);
        el.setAttribute("height", NODE_H);
        el.setAttribute("rx", 12);
      } else if (shape === "diamond") {
        el = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
        const pts = [
          [x, y - NODE_H/2],
          [x + NODE_W/2, y],
          [x, y + NODE_H/2],
          [x - NODE_W/2, y],
        ].map(p => p.join(",")).join(" ");
        el.setAttribute("points", pts);
      } else if (shape === "triangle") {
        el = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
        const pts = [
          [x, y - NODE_H/2],
          [x + NODE_W/2, y + NODE_H/2],
          [x - NODE_W/2, y + NODE_H/2],
        ].map(p => p.join(",")).join(" ");
        el.setAttribute("points", pts);
      } else if (shape === "hex") {
        el = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
        const w = NODE_W/2, h = NODE_H/2;
        const pts = [
          [x - w*0.55, y - h],
          [x + w*0.55, y - h],
          [x + w,      y],
          [x + w*0.55, y + h],
          [x - w*0.55, y + h],
          [x - w,      y],
        ].map(p => p.join(",")).join(" ");
        el.setAttribute("points", pts);
      } else {
        // fallback
        el = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        el.setAttribute("cx", x);
        el.setAttribute("cy", y);
        el.setAttribute("r", Math.min(NODE_W, NODE_H) * 0.42);
      }

      el.setAttribute("fill", fillCol);
      el.setAttribute("stroke", strokeCol);
      el.setAttribute("stroke-width", "2.2");
      el.setAttribute("filter", "drop-shadow(0px 8px 18px rgba(0,0,0,0.45))");
      el.style.pointerEvents = "all";

      // Click to follow link
      if (n.url) {
        el.style.cursor = "pointer";
        el.addEventListener("click", (ev) => {
          // If dragging, ignore click (handled by drag logic)
          if (dragging && dragging.id === id) return;
          ev.stopPropagation();
          safeOpen(n.url);
        });
      }

      g.appendChild(el);

      // Label: prefer node text; fallback to id
      const labelText = n.text ? truncateLabel(n.text, 22) : id;
      const textEl = document.createElementNS("http://www.w3.org/2000/svg", "text");
      textEl.setAttribute("x", x);
      textEl.setAttribute("y", y);
      textEl.setAttribute("text-anchor", "middle");
      textEl.setAttribute("dominant-baseline", "middle");
      textEl.setAttribute("font-family", "system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial");
      textEl.setAttribute("font-size", "13");
      textEl.setAttribute("font-weight", "700");
      textEl.setAttribute("fill", labelCol);
      textEl.style.pointerEvents = "none";
      textEl.textContent = labelText;

      g.appendChild(textEl);

      // Drag handlers
      g.addEventListener("pointerdown", (ev) => startDrag(ev, id));

      nodeLayer.appendChild(g);
    }
  }

  function safeOpen(url) {
    try {
      window.open(url, "_blank", "noopener,noreferrer");
    } catch {
      location.href = url;
    }
  }

  let lastNavTime = 0;
  function openUrl(url) {
    if (!url) return;
    const now = performance.now();
    if (now - lastNavTime < 250) return;
    lastNavTime = now;
    safeOpen(url);
  }

  // -----------------------------
  // Dragging
  // -----------------------------
  let dragging = null;
  let dragMoved = false;
  let dragRaf = 0;
  let dragHashTimer = 0;

  function startDrag(ev, id) {
    // Only left click / primary pointer
    if (ev.button !== 0) return;
    ev.preventDefault();
    ev.stopPropagation();
    const p = svgPointFromEvent(ev);
    const cur = state.pos[id] || [p.x, p.y];
    dragging = {
      id,
      dx: cur[0] - p.x,
      dy: cur[1] - p.y,
      pointerId: ev.pointerId
    };
    dragMoved = false;
    $svg.setPointerCapture(ev.pointerId);
    // Move immediately on down feels better
    moveDrag(ev);
  }

  function moveDrag(ev) {
    if (!dragging) return;
    const p = svgPointFromEvent(ev);
    const nx = Math.round(p.x + dragging.dx);
    const ny = Math.round(p.y + dragging.dy);
    const id = dragging.id;

    const prev = state.pos[id] || [0,0];
    if (prev[0] !== nx || prev[1] !== ny) dragMoved = true;

    state.pos[id] = [nx, ny];

    // Throttle full render to animation frames
    if (!dragRaf) {
      dragRaf = requestAnimationFrame(() => {
        dragRaf = 0;
        renderAll();
      });
    }

    // Debounce hash updates while dragging (still all state in URL)
    clearTimeout(dragHashTimer);
    dragHashTimer = setTimeout(() => syncHash({ replace: true }), 120);
  }

  function endDrag(ev) {
    if (!dragging) return;
    const finishedId = dragging.id;
    const finishedMoved = dragMoved;
    try { $svg.releasePointerCapture(dragging.pointerId); } catch {}
    dragging = null;
    if (finishedMoved) {
      syncHash({ replace: true });
    } else {
      const n = diagram && diagram.nodes ? diagram.nodes.get(finishedId) : null;
      if (n && n.url) openUrl(n.url);
    }
  }

  $svg.addEventListener("pointermove", (ev) => moveDrag(ev));
  $svg.addEventListener("pointerup", (ev) => endDrag(ev));
  $svg.addEventListener("pointercancel", (ev) => endDrag(ev));

  // -----------------------------
  // App state + rendering loop
  // -----------------------------
  let state = makeDefaultState();
  let diagram = null;
  let parseTimer = 0;

  function makeDefaultState() {
    return {
      src: [
        "# Hash Diagram Game — edit this text, then copy the URL",
        "",
        "# nodes (id  [shape] [color] [url] [text...])",
        "n square red /google.com Node N",
        "m circle blue /wikipedia.org Node M",
        "t triangle green /example.com Triangle",
        "",
        "# edges (a -> b (-> c...)  [lineStyle] [color] [url] [text...])",
        "n -> m solid purple /news.ycombinator.com N to M",
        "m -> t dotted teal /slashdot.org Dotted link",
        "t -> n dashed orange /github.com Back edge",
        "",
        "# you can define nodes implicitly by referencing them in edges:",
        "a -> b -> c bold yellow /example.com Chain applies to each edge",
        "",
      ].join("\n"),
      pos: {}
    };
  }

  function applyState(newState, { replace = true, fromHash = false } = {}) {
    // Sanitize
    if (!newState || typeof newState !== "object") return;
    if (typeof newState.src !== "string") newState.src = "";
    if (!newState.pos || typeof newState.pos !== "object") newState.pos = {};
    state = newState;

    // Put src into editor (without retriggering too hard)
    if ($src.value !== state.src) $src.value = state.src;

    updateHashStatus();
  }

  function renderAll() {
    const parsed = parseSource(state.src);

    if (parsed.errors.length) {
      $parseStatus.textContent = "Parse errors";
      $parseStatus.className = "err";
      $errorBox.classList.add("show");
      $errorBox.textContent = parsed.errors.join("\n");
    } else {
      $parseStatus.textContent = "OK";
      $parseStatus.className = "ok";
      $errorBox.classList.remove("show");
      $errorBox.textContent = "";
    }

    diagram = { nodes: parsed.nodes, edges: parsed.edges };

    ensurePositions(diagram);
    prunePositions(diagram);

    render(diagram);
    updateHashStatus();
  }

  // Editor input -> parse/render -> hash
  $src.addEventListener("input", () => {
    clearTimeout(parseTimer);
    parseTimer = setTimeout(() => {
      state.src = $src.value;
      renderAll();
      syncHash({ replace: true });
    }, 160);
  });

  window.addEventListener("resize", () => {
    // Re-render to match new SVG size; state unchanged
    renderAll();
  });

  // -----------------------------
  // Boot from URL hash (if present)
  // -----------------------------
  function boot() {
    const incoming = decodeState(location.hash);
    if (incoming) {
      applyState(incoming, { replace: true, fromHash: true });
    } else {
      applyState(makeDefaultState(), { replace: true });
      syncHash({ replace: true });
    }
    renderAll();
  }

  boot();
})();
</script>
</body>
</html>
